# OC 基础





## #import 和 #include 的区别， @class 有什么用？

`@class` 一般用于头文件中需要声明该类的某个实例变量的时候用到，在`.m`文件中还是需要使用`#import`

`#improt` 比起 `#imclude`的好处在于**不会一起交叉编译**



## readwirte、 readonly、assign、retain、copy、nonatomic 属性关键词的作用。

`@property`是一个属性访问声明，括号内支持一下几个属性关键词：

1. getter=getName，setter=setName， 设置属性存取方法的别名。
2. readwrite、readonly， 设置可供访问的级别。
3. assign，setter方法可以直接赋值，不进行 retain 操作，为了解决原类型与循环引用的问题。
4. retain，setter方法对参数进行 release 旧值，再 retain 新值，所有实现都是这个顺序。
5. copy, setter 方法进行 copy 操作，与 retain 处理流程一样，先旧值 release， 再 copy 出新的对象， retainCount 为1 。这是为了减少对上下文的依赖而引入的机制。
6. nonatomic，非原子性访问，不加同步，多线程并发访问会提高性能。注意，如果不加此属性，则默认是两个访问方法都为原子性访问。





## 在一个对象的方法里面： self.name = "obj"; 和 _name=“obj” 有什么区别？



使用点语法会调用setter方法赋值。





## 简述self.name = nil 的机制，以及与[name release]的区别？

 

 self.name =nil;   //使用nil参数调用setName:方法

[name release］生成的访问器将自动释放以前的 name 对象





## 数组与指针的区别



1. 数组可以申请在栈区和数据区；指针可以指向任意类型的内存块
2. sizeof作用于数组时，得到的是数组所占的内存大小；作用于指针时，得到的都是4个字节的大小
3. 数组名表示数组首地址，值可以不变，不可以将++ 作用于数组名上，普通指针的值可以改变，可以将++ 作用于指针上
4. 用字符串初始化字符数组是将字符串的内容拷贝到字符数组中；用字符串初始化字符指针是将字符串的首地址赋给指针，也就是指针指向了该数组。



## static的作用



1. 函数体内 static 变量的作用范围为该函数体，不同与 auto 变量，该变量的内存只被分配一次，因此该变量的值在下次调用的时候仍然维持上次的值；
2. 在模块内的 static 全局变量可以被该模块内的其他函数访问，但是不能被模块外的其他函数访问；
3. 在模块内的 static 函数只可以被这一模块内的其他函数调用，这个函数的使用范围被限制在声明他的模块内。
4. 在类的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
5. 在类中的 static 成员变量属于整个类所拥有，这个函数不接收 this 指针，因为智能访问类的 static 成员变量





## 简述内存分区的情况



1. 代码区：存放函数二进制代码
2. 数据区：系统运行时申请内存并初始化，系统推出时由系统释放。存放全局变量、静态变量、常量。
3. 堆区：通过 malloc 等函数或者 new 等操作符动态申请得到，需程序员手动申请和释放。
4. 栈区：函数模块内申请，函数结束时由系统自动释放。存放局部变量、函数参数。



## OC的优点和缺点

优点：

1. Category
2. posing
3. 动态识别
4. 指标计算
5. 弹性讯息传递
6. 不是一个过度复杂的 C 衍生语言
7. OC 可以和 Cpp 混合编程

确定

1. 不支持命名空间
2. 不支持运算符重载
3. 不支持多重继承
4. 使用动态运行时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到。（如内联函数等），性能低劣。



## 队列和栈的区别



队列和栈是两种不同的数据容器。从数据结构的角度看，它们都是线性结构，即数据元素之间的关系相同



队列是先进先出的数据结构，他在两端进行操作，一端进行入队列操作，一端进行出队列操作。



栈是一种先进后出的数据结构，它只能在栈顶进行操作，入栈和出栈都在栈顶操作。





## 类别的作用？继承和类别分别在实现中有什么区别？



category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加不能删除和修改。并且如果类别和原来类中的方法产生名称冲突，则类别奖覆盖原来的方法，因为类别具有更高的优先级。类别主要有3个作用：

1. 将类的实现分散到多个不同文件或者多个不同的框架中
2. 创建对私有方法的向前引用
3. 向对象添加非正式协议，继承可以增加修改方法，并且可以增加属性。





## id 声明的对象有什么特性？



id 是一个很重要的类型，是一个可以指向任何类型的指针或者可以理解为指向任何未知类型的指针。





## 自动释放池跟GC有什么区别？iPhone 上有 GC 吗？[poor release] 和 [pool drain]有什么区别?



iPhone 上没有GC 。 iPhone 在开发的时候没有垃圾回收机制。在垃圾回收环境中， release 是一个空操作。因此 NSAutoreleasePrrl 提供了 drain 方法。在引用计数环境中，改方法的作用等同于调用 release 。但在垃圾回收环境中，他会触发垃圾回收(如果自上次垃圾回收以来分配的内存大于当前的阀值)。因此，在通常情况下，应该是用 drain 来销毁自动释放池。





## OC的类可以多重继承么？可以实现多个接口么？重写一个类的方式用继承好还是分类好？为什么？



OC 只支持单继承，如果要实现多继承的话，可以通过类别和协议的方法来实现，Cocoa 中所有的类都是 NSObject 的字类，多继承在这里是用 protocol 委托代理来实现的。



## 线程与进程的区别和联系？



线程和进程都是由操作系统所体会的程序的基本单元，系统利用该基本单元实现系统对应的并发行。进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下，不会对其他进程产生影响，而线程是一个进程的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的持续要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。



## OC 有私有方法吗？ 私有变量呢？



OC类里面的方法只有两种，静态方法和实例方法。这似乎就不是完整的面向对象了，按照OO的原则就是一个对象只暴露有用的东西。如果没有私有方法的话，对于一些小范围的代码重用就不那么顺手了，在类里面声明一个私有方法

```objective-c
@interface Controller : NSObject { 
  NSString *something; 
}

+ (void)thisIsAStaticMethod;
- (void)thisIsAnInstanceMethod;
@end
  
@interface Controller (private) 
  
- (void)thisIsAPrivateMethod;
@end

```



`@private`可以用来修饰私有变量

在OC中，所有实例变量默认都是私有的，所有实例方法默认都是公有的。



## HTTP 协议中 POST 和 GET 的区别？



1. **GET方法**
   1. GET方法提交的数据不安全，数据置于请求行，客户端地址栏可见。
   2. GET方法提交的数据大小有限
   3. GET方法不可以设置书签
2. **POST方法**
   1. POST方法提交的数据安全，数据置于消息主体内，客户端不可见
   2. POST方法提交的数据大小没有限制
   3. POST方法可以设置书签








































## iOS 的系统架构？



iOS的系统架构分为

1. 核心操作层 Core OS layer
2. 核心服务层 Core Service layer
3. 媒体层  Media layer
4. Cocoa 界面服务层 Cocoa Touch Layer



## 